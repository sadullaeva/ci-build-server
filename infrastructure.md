# Комментарии к ДЗ по теме "Инфраструктура"

Я разделила репозитории билд-сервера и билд-агента, поскольку, если речь идет о масштабировании, то так это будет делать удобнее, в моем понимании.
Плюс, это помогало не смешивать - что делает сервер, а что - агент.

## Требования и их реализация

>Сервер должен максимально утилизировать имеющихся агентов.

Сервер запускает новую пачку билдов на сборку по таймеру - каждые 30 секунд проверяет, есть ли свободные агенты и ожидающие билды, и использует доступных агентов по максимуму.
Тут отдельно хотелось бы сказать, что тут есть место для оптимизации - например, чтобы агенту выдавалась следующая задача сразу, как он освободится, а не по таймеру.
Я решила сначала сделать работающий вариант, а оптимизацией займусь позже.

>Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать между сборками.

То, что агент пректратил работать между сборками, сервер понимает, если при попытке выдать задание на сборку агент возвращает 500.
Тогда сервер исключает агента из своего пула агентов, и возвращает билд в очередь.
Таким образом, мы не теряем наш билд, и быстро избавляемся от отвалившихся агентов.

>Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать в процессе выполнения сборки.

Для корректной обработки такой ситуации я добавила агенту ручку `/health`.
Когда агент получает задание, автоматически запускается проверка по таймеру, что сервер работает.
Если проверка выявляет, что агент перестал работать, текущая задача отменяется, а агент самоудаляется из пула агентов.
Решение сделать именно так обосновано тем, что момент, когда мы имели доступ к данным билда, уже упущен.
Сущность агента на сервере знает только id своей текущей задачи, и большее, что она может сделать перед самоуничтожением - это отметить билд.
Наверное, как вариант, можно было бы сделать так, чтобы сущность агента на сервере хранила не только id, но и всю информацию о текущей задаче, и тогда можно было бы закинуть этот билд обратно в очередь и он бы автоматически потом назначился другому сборщику.
Я не стала так делать, потому что, если вдруг это билд похоронил билд-агента при выполнении сборки, то мы таким образом выкосим всех своих агентов одного за другим. Безопаснее просто отменить этот билд.

>Агент должен корректно обрабатывать ситуацию, когда при старте не смог соединиться с сервером.

Агент пытается соединиться с сервером каждые 30 секунд, пока у него это не получится.
Такое решение принято потому, что билд-агент без сервера не будет делать вообще ничего.

>Агент должен корректно обрабатывать ситуацию, когда при отправке результатов сборки не смог соединиться с сервером.

Агент логирует, что он не смог отправить результаты, и больше ничего не делает.
На самом деле, сейчас я понимаю, что это не является прям уж корректной обработкой ситуации.
Во время реализации я этот момент упустила, поскольку сервер работает стабильно, и не ответить мог только в случае, если не работает.
А нестабильно работает API хранилища, а потому я больше постаралась обработать некорректные ситуации с этой стороны.

## Ситуации, которые я сама придумала и их реализация

>Сервер не смог при старте получить настройки

Поскольку без настроек все бессмысленно, сервер стучит в хранилище за настройками каждые 30 секунд, пока он их не получит (в любой непонятной ситуации ждем 30 секунд).

>Серверу нужно получать билды, чтобы отправлять их на сборку

Тут была трудность с устройством хранилища.
Хранилище возвращает билды, начиная с самых новых, при этом нет возможности отфильтровать билды по статусу (сервер интересуют только waiting билды).
То есть, есть вариант, что в где-то миллионе успешно завершенных билдов найдется один waiting, и мы не должны оставить его без внимания.
Таким образом, сейчас сервер постранично выгружает все билды, фильтрует их по статусу, хранит у себя в памяти только те, что со статусом waiting.
Когда все билды выгружены, мы обратным проходом по массиву засовываем все билды в очередь, чтобы они билдились от старых к новым.
Ну, и, каждые 30 секунд сервер проверяет, не появилось ли чего-нибудь новенького.
При такой реализации мы не упустим ни один ожидающий билд, но можем вылететь по памяти, если в хранилище будет миллиард ожидающих билдов.
Эту проблему я решать пока не стала, поскольку, если бы речь шла о серьезных масштабах, нам бы все же пришлось немного переделать хранилище, чтобы оно умело возвращать, во-первых, только ожидающие билды, во-вторых, начиная со старых, а не с новых.

>При старте билда не сработал запрос на обновление статуса билда в хранилище

В этом случае сервер попытается сменить статус билда на cancelled. Правда остановить билд-агента уже не получится.
Тут, наверное, можно было бы попробовать отправить запрос несколько раз, но мы не знаем, как долго будет длится билд, а значит, есть вероятность, что билд уже завершится, пока мы будем пытаться отправить start. Во избежание коллизий, мы просто отменяем билд.

>При завершении билда не сработал запрос на обновление статуса билда в хранилище

Поскольку все работа уже проделана, очень жаль было бы терять результаты.
Поэтому сервер пытается 3 раза, после чего прекращает попытки, и посылает запрос на смену статуса билда на cancelled.
Если ничего не получилось, он больше ничего не пытается сделать.
